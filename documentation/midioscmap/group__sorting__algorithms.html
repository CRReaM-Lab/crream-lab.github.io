<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MidiOscMap: Sorting</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MidiOscMap
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__sorting__algorithms.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Topics</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Sorting<div class="ingroups"><a class="el" href="group__algorithms.html">Algorithms</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Topics</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__set__algorithms.html">Set Operation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__binary__search__algorithms.html">Binary Search</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__heap__algorithms.html">Heap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga544d74b2d5d0dd2197f5fd6f02691de0" id="r_ga544d74b2d5d0dd2197f5fd6f02691de0"><td class="memItemLeft" align="right" valign="top">namespace std&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga544d74b2d5d0dd2197f5fd6f02691de0">_GLIBCXX_VISIBILITY</a> (default)</td></tr>
<tr class="separator:ga544d74b2d5d0dd2197f5fd6f02691de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga544d74b2d5d0dd2197f5fd6f02691de0" name="ga544d74b2d5d0dd2197f5fd6f02691de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga544d74b2d5d0dd2197f5fd6f02691de0">&#9670;&#160;</a></span>_GLIBCXX_VISIBILITY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">namespace std _GLIBCXX_VISIBILITY </td>
          <td>(</td>
          <td class="paramtype">default</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swaps the median value of *__a, *__b and *__c under __comp to *__result</p>
<p>This is an overload used by find algos for the Input Iterator case.</p>
<p>This is an overload used by find algos for the RAI case.</p>
<p>Provided for stable_partition to use.</p>
<p>Like find_if_not(), but uses and updates a count of the remaining range length instead of comparing against an end iterator.</p>
<p>This is an helper function for search_n overloaded for forward iterators.</p>
<p>This is an helper function for search_n overloaded for random access iterators.</p>
<p>Find last matching subsequence in a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence to match. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence to match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last iterator <code>i</code> in the range <code class="param"></code>[__first1,__last1-(__last2-__first2)) such that <code>*</code>(i+N) == <code class="param">*</code>(__first2+N) for each <code>N</code> in the range <code class="param"></code>[0,__last2-__first2), or <code class="param">__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code class="param"></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code class="param"></code>[__first2,__last2) and returns an iterator to the __first element of the sub-sequence, or <code class="param">__last1</code> if the sub-sequence is not found. The sub-sequence will be the last such subsequence contained in [__first1,__last1).</p>
<p>Because the sub-sequence must lie completely within the range <code class="param"></code>[__first1,__last1) it must start at a position less than <code class="param">__last1-</code>(__last2-__first2) where <code class="param">__last2-__first2</code> is the length of the sub-sequence. This means that the returned iterator <code>i</code> will be in the range <code class="param"></code>[__first1,__last1-(__last2-__first2))</p>
<p>Find last matching subsequence in a sequence using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence to match. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence to match. </td></tr>
    <tr><td class="paramname">__comp</td><td>The predicate to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last iterator <code>i</code> in the range <code class="param"></code>[__first1,__last1-(__last2-__first2)) such that <code>predicate</code>(*(i+N), <code class="param"></code>(__first2+N)) is true for each <code>N</code> in the range <code class="param"></code>[0,__last2-__first2), or <code class="param">__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code class="param"></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code class="param"></code>[__first2,__last2) using comp as a predicate and returns an iterator to the first element of the sub-sequence, or <code class="param">__last1</code> if the sub-sequence is not found. The sub-sequence will be the last such subsequence contained in [__first,__last1).</p>
<p>Because the sub-sequence must lie completely within the range <code class="param"></code>[__first1,__last1) it must start at a position less than <code class="param">__last1-</code>(__last2-__first2) where <code class="param">__last2-__first2</code> is the length of the sub-sequence. This means that the returned iterator <code>i</code> will be in the range <code class="param"></code>[__first1,__last1-(__last2-__first2))</p>
<p>Copy a sequence, removing elements of a given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__value</td><td>The value to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code class="param"></code>[__first,__last) not equal to <code class="param">__value</code> to the range beginning at <code class="param">__result</code>. remove_copy() is stable, so the relative order of elements that are copied is unchanged.</p>
<p>Copy a sequence, removing elements for which a predicate is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code class="param"></code>[__first,__last) for which <code class="param">__pred</code> returns false to the range beginning at <code class="param">__result</code>.</p>
<p>remove_copy_if() is stable, so the relative order of elements that are copied is unchanged.</p>
<p>Remove elements from a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__value</td><td>The value to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>All elements equal to <code class="param">__value</code> are removed from the range <code class="param"></code>[__first,__last).</p>
<p>remove() is stable, so the relative order of elements that are not removed is unchanged.</p>
<p>Elements between the end of the resulting sequence and <code class="param">__last</code> are still present, but their value is unspecified.</p>
<p>Remove elements from a sequence using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>All elements for which <code class="param">__pred</code> returns true are removed from the range <code class="param"></code>[__first,__last).</p>
<p>remove_if() is stable, so the relative order of elements that are not removed is unchanged.</p>
<p>Elements between the end of the resulting sequence and <code class="param">__last</code> are still present, but their value is unspecified.</p>
<p>Remove consecutive duplicate values from a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Removes all but the first element from each group of consecutive values that compare equal. unique() is stable, so the relative order of elements that are not removed is unchanged. Elements between the end of the resulting sequence and <code class="param">__last</code> are still present, but their value is unspecified.</p>
<p>Remove consecutive values from a sequence using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Removes all but the first element from each group of consecutive values for which <code class="param">__binary_pred</code> returns true. unique() is stable, so the relative order of elements that are not removed is unchanged. Elements between the end of the resulting sequence and <code class="param">__last</code> are still present, but their value is unspecified.</p>
<p>This is an uglified unique_copy(_InputIterator, _InputIterator, _OutputIterator,
            _BinaryPredicate) overloaded for forward iterators and output iterator as result.</p>
<p>This is an uglified unique_copy(_InputIterator, _InputIterator, _OutputIterator,
            _BinaryPredicate) overloaded for input iterators and output iterator as result.</p>
<p>This is an uglified unique_copy(_InputIterator, _InputIterator, _OutputIterator,
            _BinaryPredicate) overloaded for input iterators and forward iterator as result.</p>
<p>This is an uglified reverse(_BidirectionalIterator,
                            _BidirectionalIterator) overloaded for bidirectional iterators.</p>
<p>This is an uglified reverse(_BidirectionalIterator,
                            _BidirectionalIterator) overloaded for random access iterators.</p>
<p>Reverse a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A bidirectional iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reverse() returns no value.</dd></dl>
<p>Reverses the order of the elements in the range <code class="param"></code>[__first,__last), so that the first element becomes the last etc. For every <code>i</code> such that <code class="param">0&lt;=i&lt;=</code>(__last-__first)/2), <code class="param">reverse()</code> swaps <code class="param">*</code>(__first+i) and <code class="param">*</code>(__last-(i+1))</p>
<p>Copy a sequence, reversing its elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies the elements in the range <code class="param"></code>[__first,__last) to the range <code class="param"></code>[__result,__result+(__last-__first)) such that the order of the elements is reversed. For every <code>i</code> such that <code class="param">0&lt;=i&lt;=</code>(__last-__first), <code class="param">reverse_copy()</code> performs the assignment <code class="param">*</code>(__result+(__last-__first)-1-i) = *(__first+i). The ranges <code class="param"></code>[__first,__last) and <code class="param"></code>[__result,__result+(__last-__first)) must not overlap.</p>
<p>This is a helper function for the rotate algorithm specialized on RAIs. It returns the greatest common divisor of two integer values.</p>
<p>This is a helper function for the rotate algorithm.</p>
<p>This is a helper function for the rotate algorithm.</p>
<p>This is a helper function for the rotate algorithm.</p>
<p>Rotate the elements of a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first + (last - middle).</dd></dl>
<p>Rotates the elements of the range <code class="param"></code>[__first,__last) by <code class="param"></code>(__middle - __first) positions so that the element at <code class="param">__middle</code> is moved to <code class="param">__first</code>, the element at <code class="param">__middle+1</code> is moved to <code class="param">__first+1</code> and so on for each element in the range <code class="param"></code>[__first,__last).</p>
<p>This effectively swaps the ranges <code class="param"></code>[__first,__middle) and <code class="param"></code>[__middle,__last).</p>
<p>Performs <code class="param">*</code>(__first+(n+(__last-__middle))%(__last-__first))=*(__first+n) for each <code class="param">n</code> in the range <code class="param"></code>[0,__last-__first).</p>
<p>Copy a sequence, rotating its elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies the elements of the range <code class="param"></code>[__first,__last) to the range beginning at </p><dl class="section return"><dt>Returns</dt><dd>, rotating the copied elements by <code class="param"></code>(__middle-__first) positions so that the element at <code class="param">__middle</code> is moved to <code class="param">__result</code>, the element at <code class="param">__middle+1</code> is moved to <code class="param">__result+1</code> and so on for each element in the range <code class="param"></code>[__first,__last).</dd></dl>
<p>Performs <code class="param">*</code>(__result+(n+(__last-__middle))%(__last-__first))=*(__first+n) for each <code class="param">n</code> in the range <code class="param"></code>[0,__last-__first).</p>
<p>This is a helper function...</p>
<p>This is a helper function...</p>
<p>This is a helper function... Requires __first != __last and !__pred(__first) and __len == distance(__first, __last).</p>
<p>!__pred(__first) allows us to guarantee that we don't move-assign an element onto itself.</p>
<p>Move elements for which a predicate is true to the beginning of a sequence, preserving relative ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator <code class="param">middle</code> such that <code class="param">__pred(i)</code> is true for each iterator <code class="param">i</code> in the range <code class="param"></code>[first,middle) and false for each <code class="param">i</code> in the range <code class="param"></code>[middle,last).</dd></dl>
<p>Performs the same function as <code class="param">partition()</code> with the additional guarantee that the relative ordering of elements in each group is preserved, so any two elements <code class="param">x</code> and <code class="param">y</code> in the range <code class="param"></code>[__first,__last) such that <code class="param">__pred(x)==__pred(y)</code> will have the same relative ordering after calling <code class="param">stable_partition()</code>.</p>
<p>This is a helper function for the sort routines.</p>
<p>Copy the smallest elements of a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__result_first</td><td>A random-access iterator. </td></tr>
    <tr><td class="paramname">__result_last</td><td>Another random-access iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator indicating the end of the resulting sequence.</dd></dl>
<p>Copies and sorts the smallest N values from the range <code class="param"></code>[__first,__last) to the range beginning at <code class="param">__result_first</code>, where the number of elements to be copied, <code class="param">N</code>, is the smaller of <code class="param"></code>(__last-__first) and <code class="param"></code>(__result_last-__result_first). After the sort if <em>i</em> and <em>j</em> are iterators in the range <code class="param"></code>[__result_first,__result_first+N) such that i precedes j then *j&lt;*i is false. The value returned is <code class="param">__result_first+N</code>.</p>
<p>Copy the smallest elements of a sequence using a predicate for comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another input iterator. </td></tr>
    <tr><td class="paramname">__result_first</td><td>A random-access iterator. </td></tr>
    <tr><td class="paramname">__result_last</td><td>Another random-access iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator indicating the end of the resulting sequence.</dd></dl>
<p>Copies and sorts the smallest N values from the range <code class="param"></code>[__first,__last) to the range beginning at <code class="param">result_first</code>, where the number of elements to be copied, <code class="param">N</code>, is the smaller of <code class="param"></code>(__last-__first) and <code class="param"></code>(__result_last-__result_first). After the sort if <em>i</em> and <em>j</em> are iterators in the range <code class="param"></code>[__result_first,__result_first+N) such that i precedes j then <code class="param">__comp(*j,*i)</code> is false. The value returned is <code class="param">__result_first+N</code>.</p>
<p>This is a helper function for the sort routine.</p>
<p>This is a helper function for the sort routine.</p>
<p>This is a helper function for the sort routine.</p>
<p>@doctodo This controls some aspect of the sort routines.</p>
<p>This is a helper function for the sort routine.</p>
<p>This is a helper function...</p>
<p>This is a helper function...</p>
<p>This is a helper function for the sort routine.</p>
<p>Finds the first position in which <code class="param">__val</code> could be inserted without changing the ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element <em>not less than</em> <code class="param">__val</code>, or end() if every element is less than <code class="param">__val</code>.</dd></dl>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort.</p>
<p>Finds the last position in which <code class="param">__val</code> could be inserted without changing the ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element greater than <code class="param">__val</code>, or end() if no elements are greater than <code class="param">__val</code>.</dd></dl>
<p>Finds the last position in which <code class="param">__val</code> could be inserted without changing the ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element greater than <code class="param">__val</code>, or end() if no elements are greater than <code class="param">__val</code>.</dd></dl>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort.</p>
<p>Finds the largest subrange in which <code class="param">__val</code> could be inserted at any place in it without changing the ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An pair of iterators defining the subrange.</dd></dl>
<p>This is equivalent to </p><div class="fragment"><div class="line">std::make_pair(lower_bound(__first, __last, __val),</div>
<div class="line">               upper_bound(__first, __last, __val))</div>
</div><!-- fragment --><p> but does not actually call those functions.</p>
<p>Finds the largest subrange in which <code class="param">__val</code> could be inserted at any place in it without changing the ordering. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An pair of iterators defining the subrange.</dd></dl>
<p>This is equivalent to </p><div class="fragment"><div class="line">std::make_pair(lower_bound(__first, __last, __val, __comp),</div>
<div class="line">               upper_bound(__first, __last, __val, __comp))</div>
</div><!-- fragment --><p> but does not actually call those functions.</p>
<p>Determines whether an element exists in a range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code class="param">__val</code> (or its equivalent) is in [<code class="param">__first</code>,<code class="param">__last</code> ].</dd></dl>
<p>Note that this does not actually return an iterator to <code class="param">__val</code>. For that, use std::find or a container's specialized find member functions.</p>
<p>Determines whether an element exists in a range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The search term. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code class="param">__val</code> (or its equivalent) is in <code class="param"></code>[__first,__last].</dd></dl>
<p>Note that this does not actually return an iterator to <code class="param">__val</code>. For that, use std::find or a container's specialized find member functions.</p>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort.</p>
<p>This is a helper function for the __merge_adaptive routines.</p>
<p>This is a helper function for the __merge_adaptive routines.</p>
<p>This is a helper function for the merge routines.</p>
<p>This is a helper function for the merge routines.</p>
<p>This is a helper function for the merge routines.</p>
<p>Merges two sorted ranges in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Merges two sorted and consecutive ranges, [__first,__middle) and [__middle,__last), and puts the result in [__first,__last). The output will be sorted. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>If enough additional memory is available, this takes (__last-__first)-1 comparisons. Otherwise an NlogN algorithm is used, where N is distance(__first,__last).</p>
<p>Merges two sorted ranges in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Merges two sorted and consecutive ranges, [__first,__middle) and [middle,last), and puts the result in [__first,__last). The output will be sorted. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>If enough additional memory is available, this takes (__last-__first)-1 comparisons. Otherwise an NlogN algorithm is used, where N is distance(__first,__last).</p>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort.</p>
<p>This is a helper function for the __merge_sort_loop routines.</p>
<p>This is a helper function for the stable sorting routines.</p>
<p>Determines whether all elements of a sequence exists in a range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of search range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of search range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if each element in [__first2,__last2) is contained in order within [__first1,__last1). False otherwise.</dd></dl>
<p>This operation expects both [__first1,__last1) and [__first2,__last2) to be sorted. Searches for the presence of each element in [__first2,__last2) within [__first1,__last1). The iterators over each range only move forward, so this is a linear algorithm. If an element in [__first2,__last2) is not found before the search iterator reaches <code class="param">__last2</code>, false is returned.</p>
<p>Determines whether all elements of a sequence exists in a range using comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of search range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of search range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison function to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if each element in [__first2,__last2) is contained in order within [__first1,__last1) according to comp. False otherwise.</dd></dl>
<p>This operation expects both [__first1,__last1) and [__first2,__last2) to be sorted. Searches for the presence of each element in [__first2,__last2) within [__first1,__last1), using comp to decide. The iterators over each range only move forward, so this is a linear algorithm. If an element in [__first2,__last2) is not found before the search iterator reaches <code class="param">__last2</code>, false is returned.</p>
<p>Permute range into the next <em>dictionary</em> ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if wrapped to first permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range as a set of <em>dictionary</em> sorted sequences. Permutes the current sequence into the next one of this set. Returns true if there are more sequences to generate. If the sequence is the largest of the set, the smallest is generated and false returned.</p>
<p>Permute range into the next <em>dictionary</em> ordering using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if wrapped to first permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range [__first,__last) as a set of <em>dictionary</em> sorted sequences ordered by <code class="param">__comp</code>. Permutes the current sequence into the next one of this set. Returns true if there are more sequences to generate. If the sequence is the largest of the set, the smallest is generated and false returned.</p>
<p>Permute range into the previous <em>dictionary</em> ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if wrapped to last permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range as a set of <em>dictionary</em> sorted sequences. Permutes the current sequence into the previous one of this set. Returns true if there are more sequences to generate. If the sequence is the smallest of the set, the largest is generated and false returned.</p>
<p>Permute range into the previous <em>dictionary</em> ordering using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if wrapped to last permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range [__first,__last) as a set of <em>dictionary</em> sorted sequences ordered by <code class="param">__comp</code>. Permutes the current sequence into the previous one of this set. Returns true if there are more sequences to generate. If the sequence is the smallest of the set, the largest is generated and false returned.</p>
<p>Copy a sequence, replacing each element of one value with another value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__old_value</td><td>The value to be replaced. </td></tr>
    <tr><td class="paramname">__new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence, <code class="param">result+</code>(last-first).</dd></dl>
<p>Copies each element in the input range <code class="param"></code>[__first,__last) to the output range <code class="param"></code>[__result,__result+(__last-__first)) replacing elements equal to <code class="param">__old_value</code> with <code class="param">__new_value</code>.</p>
<p>Copy a sequence, replacing each value for which a predicate returns true with another value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
    <tr><td class="paramname">__new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence, <code class="param">__result+</code>(__last-__first).</dd></dl>
<p>Copies each element in the range <code class="param"></code>[__first,__last) to the range <code class="param"></code>[__result,__result+(__last-__first)) replacing elements for which <code class="param">__pred</code> returns true with <code class="param">__new_value</code>.</p>
<p>Apply a function to every element of a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__f</td><td>A unary function object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code class="param">__f</code> </dd></dl>
<p>Applies the function object <code class="param">__f</code> to each element in the range <code class="param"></code>[first,last). <code class="param">__f</code> must not modify the order of the sequence. If <code class="param">__f</code> has a return value it is ignored.</p>
<p>Find the first occurrence of a value in a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The value to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code class="param"></code>[__first,__last) such that <code>*i</code> == <code class="param">__val</code>, or <code class="param">__last</code> if no such iterator exists.</dd></dl>
<p>Find the first element in a sequence for which a predicate is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code class="param"></code>[__first,__last) such that <code class="param">__pred(*i)</code> is true, or <code class="param">__last</code> if no such iterator exists.</dd></dl>
<p>Find element from a set in a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of match candidates. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of match candidates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code class="param"></code>[__first1,__last1) such that <code>*i</code> == <code class="param">*</code>(i2) such that i2 is an iterator in [__first2,__last2), or <code class="param">__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code class="param"></code>[__first1,__last1) for an element that is equal to some element in the range [__first2,__last2). If found, returns an iterator in the range [__first1,__last1), otherwise returns <code class="param">__last1</code>.</p>
<p>Find element from a set in a sequence using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of match candidates. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of match candidates. </td></tr>
    <tr><td class="paramname">__comp</td><td>Predicate to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code class="param"></code>[__first1,__last1) such that <code>comp</code>(*i, <code class="param">*</code>(i2)) is true and i2 is an iterator in [__first2,__last2), or <code class="param">__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code class="param"></code>[__first1,__last1) for an element that is equal to some element in the range [__first2,__last2). If found, returns an iterator in the range [__first1,__last1), otherwise returns <code class="param">__last1</code>.</p>
<p>Find two adjacent values in a sequence that are equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> such that <code>i</code> and <code>i+1</code> are both valid iterators in <code class="param"></code>[__first,__last) and such that <code>*i</code> == <code>*</code>(i+1), or <code class="param">__last</code> if no such iterator exists.</dd></dl>
<p>Find two adjacent values in a sequence using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> such that <code>i</code> and <code>i+1</code> are both valid iterators in <code class="param"></code>[__first,__last) and such that <code class="param">__binary_pred</code>(*i,*(i+1)) is true, or <code class="param">__last</code> if no such iterator exists.</dd></dl>
<p>Count the number of copies of a value in a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__value</td><td>The value to be counted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of iterators <code>i</code> in the range <code class="param"></code>[__first,__last) for which <code>*i</code> == <code class="param">__value</code> </dd></dl>
<p>Count the elements of a sequence for which a predicate is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of iterators <code>i</code> in the range <code class="param"></code>[__first,__last) for which <code class="param">__pred(*i)</code> is true.</dd></dl>
<p>Search a sequence for a matching sub-sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code class="param"></code>[__first1,__last1-(__last2-__first2)) such that <code>*</code>(i+N) == <code class="param">*</code>(__first2+N) for each <code>N</code> in the range <code class="param"></code>[0,__last2-__first2), or <code class="param">__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code class="param"></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code class="param"></code>[__first2,__last2) and returns an iterator to the first element of the sub-sequence, or <code class="param">__last1</code> if the sub-sequence is not found.</p>
<p>Because the sub-sequence must lie completely within the range <code class="param"></code>[__first1,__last1) it must start at a position less than <code class="param">__last1-</code>(__last2-__first2) where <code class="param">__last2-__first2</code> is the length of the sub-sequence.</p>
<p>This means that the returned iterator <code>i</code> will be in the range <code class="param"></code>[__first1,__last1-(__last2-__first2))</p>
<p>Search a sequence for a matching sub-sequence using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__predicate</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code class="param"></code>[__first1,__last1-(__last2-__first2)) such that <code class="param">__predicate</code>(*(i+N),*(__first2+N)) is true for each <code>N</code> in the range <code class="param"></code>[0,__last2-__first2), or <code class="param">__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code class="param"></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code class="param"></code>[__first2,__last2), using <code class="param">__predicate</code> to determine equality, and returns an iterator to the first element of the sub-sequence, or <code class="param">__last1</code> if no such iterator exists.</p>
<dl class="section see"><dt>See also</dt><dd>search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2)</dd></dl>
<p>Search a sequence for a number of consecutive values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__count</td><td>The number of consecutive values. </td></tr>
    <tr><td class="paramname">__val</td><td>The value to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code class="param"></code>[__first,__last-__count) such that <code>*</code>(i+N) == <code class="param">__val</code> for each <code>N</code> in the range <code class="param"></code>[0,__count), or <code class="param">__last</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code class="param"></code>[__first,__last) for <code class="param">count</code> consecutive elements equal to <code class="param">__val</code>.</p>
<p>Search a sequence for a number of consecutive values using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__count</td><td>The number of consecutive values. </td></tr>
    <tr><td class="paramname">__val</td><td>The value to find. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first iterator <code>i</code> in the range <code class="param"></code>[__first,__last-__count) such that <code class="param">__binary_pred</code>(*(i+N),__val) is true for each <code>N</code> in the range <code class="param"></code>[0,__count), or <code class="param">__last</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code class="param"></code>[__first,__last) for <code class="param">__count</code> consecutive elements for which the predicate returns true.</p>
<p>Perform an operation on a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__unary_op</td><td>A unary operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output iterator equal to <code class="param">__result+</code>(__last-__first).</dd></dl>
<p>Applies the operator to each element in the input range and assigns the results to successive elements of the output sequence. Evaluates <code class="param">*</code>(__result+N)=unary_op(*(__first+N)) for each <code>N</code> in the range <code class="param"></code>[0,__last-__first).</p>
<p><code class="param">unary_op</code> must not alter its argument.</p>
<p>Perform an operation on corresponding elements of two sequences.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__binary_op</td><td>A binary operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output iterator equal to <code class="param">result+</code>(last-first).</dd></dl>
<p>Applies the operator to the corresponding elements in the two input ranges and assigns the results to successive elements of the output sequence. Evaluates <code class="param"><em></code>(__result+N)=__binary_op(*(__first1+N),</em>(__first2+N)) for each <code>N</code> in the range <code class="param"></code>[0,__last1-__first1).</p>
<p><code class="param">binary_op</code> must not alter either of its arguments.</p>
<p>Replace each occurrence of one value in a sequence with another value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__old_value</td><td>The value to be replaced. </td></tr>
    <tr><td class="paramname">__new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>replace() returns no value.</dd></dl>
<p>For each iterator <code>i</code> in the range <code class="param"></code>[__first,__last) if <code>*i</code> == <code class="param">__old_value</code> then the assignment <code>*i</code> = <code class="param">__new_value</code> is performed.</p>
<p>Replace each value in a sequence for which a predicate returns true with another value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
    <tr><td class="paramname">__new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>replace_if() returns no value.</dd></dl>
<p>For each iterator <code>i</code> in the range <code class="param"></code>[__first,__last) if <code class="param">__pred(*i)</code> is true then the assignment <code>*i</code> = <code class="param">__new_value</code> is performed.</p>
<p>Assign the result of a function object to each value in a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__gen</td><td>A function object taking no arguments and returning std::iterator_traits&lt;_ForwardIterator&gt;::value_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>generate() returns no value.</dd></dl>
<p>Performs the assignment <code>*i</code> = <code class="param">__gen()</code> for each <code>i</code> in the range <code class="param"></code>[__first,__last).</p>
<p>Assign the result of a function object to each value in a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__n</td><td>The length of the sequence. </td></tr>
    <tr><td class="paramname">__gen</td><td>A function object taking no arguments and returning std::iterator_traits&lt;_ForwardIterator&gt;::value_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the sequence, <code class="param">__first+__n</code> </dd></dl>
<p>Performs the assignment <code>*i</code> = <code class="param">__gen()</code> for each <code>i</code> in the range <code class="param"></code>[__first,__first+__n).</p>
<p>_GLIBCXX_RESOLVE_LIB_DEFECTS DR 865. More algorithms that throw away information</p>
<p>Copy a sequence, removing consecutive duplicate values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code class="param"></code>[__first,__last) to the range beginning at <code class="param">__result</code>, except that only the first element is copied from groups of consecutive elements that compare equal. unique_copy() is stable, so the relative order of elements that are copied is unchanged.</p>
<p>_GLIBCXX_RESOLVE_LIB_DEFECTS DR 241. Does unique_copy() require CopyConstructible and Assignable?</p>
<p>_GLIBCXX_RESOLVE_LIB_DEFECTS DR 538. 241 again: Does unique_copy() require CopyConstructible and Assignable?</p>
<p>Copy a sequence, removing consecutive values using a predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code class="param"></code>[__first,__last) to the range beginning at <code class="param">__result</code>, except that only the first element is copied from groups of consecutive elements for which <code class="param">__binary_pred</code> returns true. unique_copy() is stable, so the relative order of elements that are copied is unchanged.</p>
<p>_GLIBCXX_RESOLVE_LIB_DEFECTS DR 241. Does unique_copy() require CopyConstructible and Assignable?</p>
<p>Randomly shuffle the elements of a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Reorder the elements in the range <code class="param"></code>[__first,__last) using a random distribution, so that every possible ordering of the sequence is equally likely.</p>
<p>Shuffle the elements of a sequence using a random number generator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__rand</td><td>The RNG functor or function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Reorders the elements in the range <code class="param"></code>[__first,__last) using <code class="param">__rand</code> to provide a random distribution. Calling <code class="param">__rand(N)</code> for a positive integer <code class="param">N</code> should return a randomly chosen integer from the range [0,N).</p>
<p>Move elements for which a predicate is true to the beginning of a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator <code class="param">middle</code> such that <code class="param">__pred(i)</code> is true for each iterator <code class="param">i</code> in the range <code class="param"></code>[__first,middle) and false for each <code class="param">i</code> in the range <code class="param"></code>[middle,__last).</dd></dl>
<p><code class="param">__pred</code> must not modify its operand. <code class="param">partition()</code> does not preserve the relative ordering of elements in each group, use <code class="param">stable_partition()</code> if this is needed.</p>
<p>Sort the smallest elements of a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the smallest <code class="param"></code>(__middle-__first) elements in the range <code class="param"></code>[first,last) and moves them to the range <code class="param"></code>[__first,__middle). The order of the remaining elements in the range <code class="param"></code>[__middle,__last) is undefined. After the sort if <em>i</em> and <em>j</em> are iterators in the range <code class="param"></code>[__first,__middle) such that i precedes j and <em>k</em> is an iterator in the range <code class="param"></code>[__middle,__last) then *j&lt;*i and *k&lt;*i are both false.</p>
<p>Sort the smallest elements of a sequence using a predicate for comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the smallest <code class="param"></code>(__middle-__first) elements in the range <code class="param"></code>[__first,__last) and moves them to the range <code class="param"></code>[__first,__middle). The order of the remaining elements in the range <code class="param"></code>[__middle,__last) is undefined. After the sort if <em>i</em> and <em>j</em> are iterators in the range <code class="param"></code>[__first,__middle) such that i precedes j and <em>k</em> is an iterator in the range <code class="param"></code>[__middle,__last) then <code class="param">*__comp</code>(j,*i) and <code class="param">__comp(*k,*i)</code> are both false.</p>
<p>Sort a sequence just enough to find a particular position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__nth</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Rearranges the elements in the range <code class="param"></code>[__first,__last) so that <code class="param">*__nth</code> is the same element that would have been in that position had the whole sequence been sorted. The elements either side of <code class="param">*__nth</code> are not completely sorted, but for any iterator <em>i</em> in the range <code class="param"></code>[__first,__nth) and any iterator <em>j</em> in the range <code class="param"></code>[__nth,__last) it holds that *j &lt; *i is false.</p>
<p>Sort a sequence just enough to find a particular position using a predicate for comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__nth</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Rearranges the elements in the range <code class="param"></code>[__first,__last) so that <code class="param">*__nth</code> is the same element that would have been in that position had the whole sequence been sorted. The elements either side of <code class="param">*__nth</code> are not completely sorted, but for any iterator <em>i</em> in the range <code class="param"></code>[__first,__nth) and any iterator <em>j</em> in the range <code class="param"></code>[__nth,__last) it holds that <code class="param">__comp(*j,*i)</code> is false.</p>
<p>Sort the elements of a sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code class="param"></code>[__first,__last) in ascending order, such that for each iterator <em>i</em> in the range <code class="param"></code>[__first,__last-1), <br  />
 *(i+1)&lt;*i is false.</p>
<p>The relative ordering of equivalent elements is not preserved, use <code class="param">stable_sort()</code> if this is needed.</p>
<p>Sort the elements of a sequence using a predicate for comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code class="param"></code>[__first,__last) in ascending order, such that <code class="param">__comp</code>(*(i+1),*i) is false for every iterator <em>i</em> in the range <code class="param"></code>[__first,__last-1).</p>
<p>The relative ordering of equivalent elements is not preserved, use <code class="param">stable_sort()</code> if this is needed.</p>
<p>Merges two sorted ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An iterator pointing to the end of the merged range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element <em>not less than</em> <em>val</em>.</dd></dl>
<p>Merges the ranges <code class="param"></code>[__first1,__last1) and <code class="param"></code>[__first2,__last2) into the sorted range <code class="param"></code>[__result, __result + (__last1-__first1) + (__last2-__first2)). Both input ranges must be sorted, and the output range must not overlap with either of the input ranges. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>Merges two sorted ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An iterator pointing to the end of the merged range. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first element "not less
                than" <em>val</em>.</dd></dl>
<p>Merges the ranges <code class="param"></code>[__first1,__last1) and <code class="param"></code>[__first2,__last2) into the sorted range <code class="param"></code>[__result, __result + (__last1-__first1) + (__last2-__first2)). Both input ranges must be sorted, and the output range must not overlap with either of the input ranges. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort.</p>
<p>Sort the elements of a sequence, preserving the relative order of equivalent elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code class="param"></code>[__first,__last) in ascending order, such that for each iterator <code class="param">i</code> in the range <code class="param"></code>[__first,__last-1), <code class="param">*</code>(i+1)&lt;*i is false.</p>
<p>The relative ordering of equivalent elements is preserved, so any two elements <code class="param">x</code> and <code class="param">y</code> in the range <code class="param"></code>[__first,__last) such that <code class="param">x&lt;y</code> is false and <code class="param">y&lt;x</code> is false will have the same relative ordering after calling <code class="param">stable_sort()</code>.</p>
<p>Sort the elements of a sequence using a predicate for comparison, preserving the relative order of equivalent elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code class="param"></code>[__first,__last) in ascending order, such that for each iterator <code class="param">i</code> in the range <code class="param"></code>[__first,__last-1), <code class="param">__comp</code>(*(i+1),*i) is false.</p>
<p>The relative ordering of equivalent elements is preserved, so any two elements <code class="param">x</code> and <code class="param">y</code> in the range <code class="param"></code>[__first,__last) such that <code class="param">__comp(x,y)</code> is false and <code class="param">__comp(y,x)</code> is false will have the same relative ordering after calling <code class="param">stable_sort()</code>.</p>
<p>Return the union of two sorted ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in each range in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that element is copied and the iterator advanced. If an element is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the union of two sorted ranges using a comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__comp</td><td>The comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in each range in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to <code class="param">__comp</code>, that element is copied and the iterator advanced. If an equivalent element according to <code class="param">__comp</code> is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the intersection of two sorted ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in both ranges in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that iterator advances. If an element is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the intersection of two sorted ranges using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__comp</td><td>The comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in both ranges in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to <code class="param">__comp</code>, that iterator advances. If an element is contained in both ranges according to <code class="param">__comp</code>, the element from the first range is copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the difference of two sorted ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in the first range but not the second in order to the output range. Iterators increment for each range. When the current element of the first range is less than the second, that element is copied and the iterator advances. If the current element of the second range is less, the iterator advances, but no element is copied. If an element is contained in both ranges, no elements are copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the difference of two sorted ranges using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__comp</td><td>The comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in the first range but not the second in order to the output range. Iterators increment for each range. When the current element of the first range is less than the second according to <code class="param">__comp</code>, that element is copied and the iterator advances. If the current element of the second range is less, no element is copied and the iterator advances. If an element is contained in both ranges according to <code class="param">__comp</code>, no elements are copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the symmetric difference of two sorted ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in one range but not the other in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that element is copied and the iterator advances. If an element is contained in both ranges, no elements are copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the symmetric difference of two sorted ranges using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__comp</td><td>The comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in one range but not the other in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to <code class="param">comp</code>, that element is copied and the iterator advances. If an element is contained in both ranges according to <code class="param">__comp</code>, no elements are copied and both ranges advance. The output range may not overlap either input range.</p>
<p>Return the minimum element in a range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing the first instance of the smallest value.</dd></dl>
<p>Return the minimum element in a range using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing the first instance of the smallest value according to __comp.</dd></dl>
<p>Return the maximum element in a range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing the first instance of the largest value.</dd></dl>
<p>Return the maximum element in a range using comparison functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing the first instance of the largest value according to __comp.</dd></dl>

<p class="definition">Definition at line <a class="el" href="stl__algo_8h_source.html#l00071">71</a> of file <a class="el" href="stl__algo_8h_source.html">stl_algo.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
